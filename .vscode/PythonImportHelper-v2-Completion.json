[
    {
        "label": "runpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "runpy",
        "description": "runpy",
        "detail": "runpy",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "site",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "site",
        "description": "site",
        "detail": "site",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Type",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypedDict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeAlias",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Literal",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypedDict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Type",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeAlias",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Literal",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypedDict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Type",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeAlias",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Literal",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypedDict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Type",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeAlias",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Literal",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypedDict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Type",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Generic",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeAlias",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Literal",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "override",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "ClassVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Literal",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Type",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "AsyncGenerator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Literal",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "logging",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "logging",
        "description": "logging",
        "detail": "logging",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "ValidationError",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "ValidationError",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "Field",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "create_model",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "Field",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "anthropic",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "anthropic",
        "description": "anthropic",
        "detail": "anthropic",
        "documentation": {}
    },
    {
        "label": "ToolChoiceParam",
        "importPath": "anthropic.types",
        "description": "anthropic.types",
        "isExtraImport": true,
        "detail": "anthropic.types",
        "documentation": {}
    },
    {
        "label": "ToolUnionParam",
        "importPath": "anthropic.types",
        "description": "anthropic.types",
        "isExtraImport": true,
        "detail": "anthropic.types",
        "documentation": {}
    },
    {
        "label": "MessageParam",
        "importPath": "anthropic.types",
        "description": "anthropic.types",
        "isExtraImport": true,
        "detail": "anthropic.types",
        "documentation": {}
    },
    {
        "label": "TextBlockParam",
        "importPath": "anthropic.types",
        "description": "anthropic.types",
        "isExtraImport": true,
        "detail": "anthropic.types",
        "documentation": {}
    },
    {
        "label": "Message",
        "importPath": "anthropic.types",
        "description": "anthropic.types",
        "isExtraImport": true,
        "detail": "anthropic.types",
        "documentation": {}
    },
    {
        "label": "Model",
        "importPath": "anthropic.types",
        "description": "anthropic.types",
        "isExtraImport": true,
        "detail": "anthropic.types",
        "documentation": {}
    },
    {
        "label": "SingletonMeta",
        "importPath": "think_reason_learn.core._singleton",
        "description": "think_reason_learn.core._singleton",
        "isExtraImport": true,
        "detail": "think_reason_learn.core._singleton",
        "documentation": {}
    },
    {
        "label": "SingletonMeta",
        "importPath": "think_reason_learn.core._singleton",
        "description": "think_reason_learn.core._singleton",
        "isExtraImport": true,
        "detail": "think_reason_learn.core._singleton",
        "documentation": {}
    },
    {
        "label": "SingletonMeta",
        "importPath": "think_reason_learn.core._singleton",
        "description": "think_reason_learn.core._singleton",
        "isExtraImport": true,
        "detail": "think_reason_learn.core._singleton",
        "documentation": {}
    },
    {
        "label": "SingletonMeta",
        "importPath": "think_reason_learn.core._singleton",
        "description": "think_reason_learn.core._singleton",
        "isExtraImport": true,
        "detail": "think_reason_learn.core._singleton",
        "documentation": {}
    },
    {
        "label": "SingletonMeta",
        "importPath": "think_reason_learn.core._singleton",
        "description": "think_reason_learn.core._singleton",
        "isExtraImport": true,
        "detail": "think_reason_learn.core._singleton",
        "documentation": {}
    },
    {
        "label": "NOT_GIVEN",
        "importPath": "anthropic._types",
        "description": "anthropic._types",
        "isExtraImport": true,
        "detail": "anthropic._types",
        "documentation": {}
    },
    {
        "label": "NotGiven",
        "importPath": "anthropic._types",
        "description": "anthropic._types",
        "isExtraImport": true,
        "detail": "anthropic._types",
        "documentation": {}
    },
    {
        "label": "genai",
        "importPath": "google",
        "description": "google",
        "isExtraImport": true,
        "detail": "google",
        "documentation": {}
    },
    {
        "label": "types",
        "importPath": "google.genai",
        "description": "google.genai",
        "isExtraImport": true,
        "detail": "google.genai",
        "documentation": {}
    },
    {
        "label": "AsyncOpenAI",
        "importPath": "openai",
        "description": "openai",
        "isExtraImport": true,
        "detail": "openai",
        "documentation": {}
    },
    {
        "label": "OpenAI",
        "importPath": "openai",
        "description": "openai",
        "isExtraImport": true,
        "detail": "openai",
        "documentation": {}
    },
    {
        "label": "Response",
        "importPath": "openai.types.responses",
        "description": "openai.types.responses",
        "isExtraImport": true,
        "detail": "openai.types.responses",
        "documentation": {}
    },
    {
        "label": "ChatModel",
        "importPath": "openai.types",
        "description": "openai.types",
        "isExtraImport": true,
        "detail": "openai.types",
        "documentation": {}
    },
    {
        "label": "NOT_GIVEN",
        "importPath": "openai._types",
        "description": "openai._types",
        "isExtraImport": true,
        "detail": "openai._types",
        "documentation": {}
    },
    {
        "label": "NotGiven",
        "importPath": "openai._types",
        "description": "openai._types",
        "isExtraImport": true,
        "detail": "openai._types",
        "documentation": {}
    },
    {
        "label": "contextlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "contextlib",
        "description": "contextlib",
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "Client",
        "importPath": "xai_sdk",
        "description": "xai_sdk",
        "isExtraImport": true,
        "detail": "xai_sdk",
        "documentation": {}
    },
    {
        "label": "AsyncClient",
        "importPath": "xai_sdk",
        "description": "xai_sdk",
        "isExtraImport": true,
        "detail": "xai_sdk",
        "documentation": {}
    },
    {
        "label": "system",
        "importPath": "xai_sdk.chat",
        "description": "xai_sdk.chat",
        "isExtraImport": true,
        "detail": "xai_sdk.chat",
        "documentation": {}
    },
    {
        "label": "user",
        "importPath": "xai_sdk.chat",
        "description": "xai_sdk.chat",
        "isExtraImport": true,
        "detail": "xai_sdk.chat",
        "documentation": {}
    },
    {
        "label": "Message",
        "importPath": "xai_sdk.proto.v6.chat_pb2",
        "description": "xai_sdk.proto.v6.chat_pb2",
        "isExtraImport": true,
        "detail": "xai_sdk.proto.v6.chat_pb2",
        "documentation": {}
    },
    {
        "label": "MessageRole",
        "importPath": "xai_sdk.proto.v6.chat_pb2",
        "description": "xai_sdk.proto.v6.chat_pb2",
        "isExtraImport": true,
        "detail": "xai_sdk.proto.v6.chat_pb2",
        "documentation": {}
    },
    {
        "label": "settings",
        "importPath": "think_reason_learn.core._config",
        "description": "think_reason_learn.core._config",
        "isExtraImport": true,
        "detail": "think_reason_learn.core._config",
        "documentation": {}
    },
    {
        "label": "math",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "math",
        "description": "math",
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "field",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "field",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "asdict",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "BaseSettings",
        "importPath": "pydantic_settings",
        "description": "pydantic_settings",
        "isExtraImport": true,
        "detail": "pydantic_settings",
        "documentation": {}
    },
    {
        "label": "PydanticBaseSettingsSource",
        "importPath": "pydantic_settings",
        "description": "pydantic_settings",
        "isExtraImport": true,
        "detail": "pydantic_settings",
        "documentation": {}
    },
    {
        "label": "SettingsConfigDict",
        "importPath": "pydantic_settings",
        "description": "pydantic_settings",
        "isExtraImport": true,
        "detail": "pydantic_settings",
        "documentation": {}
    },
    {
        "label": "asyncio",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "asyncio",
        "description": "asyncio",
        "detail": "asyncio",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "uuid4",
        "importPath": "uuid",
        "description": "uuid",
        "isExtraImport": true,
        "detail": "uuid",
        "documentation": {}
    },
    {
        "label": "deepcopy",
        "importPath": "copy",
        "description": "copy",
        "isExtraImport": true,
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "datetime",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "datetime",
        "description": "datetime",
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "re",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "re",
        "description": "re",
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "orjson",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "orjson",
        "description": "orjson",
        "detail": "orjson",
        "documentation": {}
    },
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "numpy.typing",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy.typing",
        "description": "numpy.typing",
        "detail": "numpy.typing",
        "documentation": {}
    },
    {
        "label": "pandas",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pandas",
        "description": "pandas",
        "detail": "pandas",
        "documentation": {}
    },
    {
        "label": "LLMChoice",
        "importPath": "think_reason_learn.core.llms",
        "description": "think_reason_learn.core.llms",
        "isExtraImport": true,
        "detail": "think_reason_learn.core.llms",
        "documentation": {}
    },
    {
        "label": "TokenCount",
        "importPath": "think_reason_learn.core.llms",
        "description": "think_reason_learn.core.llms",
        "isExtraImport": true,
        "detail": "think_reason_learn.core.llms",
        "documentation": {}
    },
    {
        "label": "llm",
        "importPath": "think_reason_learn.core.llms",
        "description": "think_reason_learn.core.llms",
        "isExtraImport": true,
        "detail": "think_reason_learn.core.llms",
        "documentation": {}
    },
    {
        "label": "DataError",
        "importPath": "think_reason_learn.core._exceptions",
        "description": "think_reason_learn.core._exceptions",
        "isExtraImport": true,
        "detail": "think_reason_learn.core._exceptions",
        "documentation": {}
    },
    {
        "label": "LLMError",
        "importPath": "think_reason_learn.core._exceptions",
        "description": "think_reason_learn.core._exceptions",
        "isExtraImport": true,
        "detail": "think_reason_learn.core._exceptions",
        "documentation": {}
    },
    {
        "label": "CorruptionError",
        "importPath": "think_reason_learn.core._exceptions",
        "description": "think_reason_learn.core._exceptions",
        "isExtraImport": true,
        "detail": "think_reason_learn.core._exceptions",
        "documentation": {}
    },
    {
        "label": "JSONValue",
        "importPath": "think_reason_learn.core._types",
        "description": "think_reason_learn.core._types",
        "isExtraImport": true,
        "detail": "think_reason_learn.core._types",
        "documentation": {}
    },
    {
        "label": "bin_dir",
        "kind": 5,
        "importPath": ".venv.bin.activate_this",
        "description": ".venv.bin.activate_this",
        "peekOfCode": "bin_dir = os.path.dirname(abs_file)\nbase = bin_dir[: -len('bin') - 1]  # strip away the bin part from the __file__, plus the path separator\n# prepend bin to PATH (this file is inside the bin directory)\nos.environ[\"PATH\"] = os.pathsep.join([bin_dir, *os.environ.get(\"PATH\", \"\").split(os.pathsep)])\nos.environ[\"VIRTUAL_ENV\"] = base  # virtual env is right above bin directory\nos.environ[\"VIRTUAL_ENV_PROMPT\"] = 'think-reason-learn-py3.13' or os.path.basename(base)\n# add the virtual environments libraries to the host python import mechanism\nprev_length = len(sys.path)\nfor lib in '../lib/python3.13/site-packages'.split(os.pathsep):\n    path = os.path.realpath(os.path.join(bin_dir, lib))",
        "detail": ".venv.bin.activate_this",
        "documentation": {}
    },
    {
        "label": "base",
        "kind": 5,
        "importPath": ".venv.bin.activate_this",
        "description": ".venv.bin.activate_this",
        "peekOfCode": "base = bin_dir[: -len('bin') - 1]  # strip away the bin part from the __file__, plus the path separator\n# prepend bin to PATH (this file is inside the bin directory)\nos.environ[\"PATH\"] = os.pathsep.join([bin_dir, *os.environ.get(\"PATH\", \"\").split(os.pathsep)])\nos.environ[\"VIRTUAL_ENV\"] = base  # virtual env is right above bin directory\nos.environ[\"VIRTUAL_ENV_PROMPT\"] = 'think-reason-learn-py3.13' or os.path.basename(base)\n# add the virtual environments libraries to the host python import mechanism\nprev_length = len(sys.path)\nfor lib in '../lib/python3.13/site-packages'.split(os.pathsep):\n    path = os.path.realpath(os.path.join(bin_dir, lib))\n    site.addsitedir(path.decode(\"utf-8\") if '' else path)",
        "detail": ".venv.bin.activate_this",
        "documentation": {}
    },
    {
        "label": "os.environ[\"PATH\"]",
        "kind": 5,
        "importPath": ".venv.bin.activate_this",
        "description": ".venv.bin.activate_this",
        "peekOfCode": "os.environ[\"PATH\"] = os.pathsep.join([bin_dir, *os.environ.get(\"PATH\", \"\").split(os.pathsep)])\nos.environ[\"VIRTUAL_ENV\"] = base  # virtual env is right above bin directory\nos.environ[\"VIRTUAL_ENV_PROMPT\"] = 'think-reason-learn-py3.13' or os.path.basename(base)\n# add the virtual environments libraries to the host python import mechanism\nprev_length = len(sys.path)\nfor lib in '../lib/python3.13/site-packages'.split(os.pathsep):\n    path = os.path.realpath(os.path.join(bin_dir, lib))\n    site.addsitedir(path.decode(\"utf-8\") if '' else path)\nsys.path[:] = sys.path[prev_length:] + sys.path[0:prev_length]\nsys.real_prefix = sys.prefix",
        "detail": ".venv.bin.activate_this",
        "documentation": {}
    },
    {
        "label": "os.environ[\"VIRTUAL_ENV\"]",
        "kind": 5,
        "importPath": ".venv.bin.activate_this",
        "description": ".venv.bin.activate_this",
        "peekOfCode": "os.environ[\"VIRTUAL_ENV\"] = base  # virtual env is right above bin directory\nos.environ[\"VIRTUAL_ENV_PROMPT\"] = 'think-reason-learn-py3.13' or os.path.basename(base)\n# add the virtual environments libraries to the host python import mechanism\nprev_length = len(sys.path)\nfor lib in '../lib/python3.13/site-packages'.split(os.pathsep):\n    path = os.path.realpath(os.path.join(bin_dir, lib))\n    site.addsitedir(path.decode(\"utf-8\") if '' else path)\nsys.path[:] = sys.path[prev_length:] + sys.path[0:prev_length]\nsys.real_prefix = sys.prefix\nsys.prefix = base",
        "detail": ".venv.bin.activate_this",
        "documentation": {}
    },
    {
        "label": "os.environ[\"VIRTUAL_ENV_PROMPT\"]",
        "kind": 5,
        "importPath": ".venv.bin.activate_this",
        "description": ".venv.bin.activate_this",
        "peekOfCode": "os.environ[\"VIRTUAL_ENV_PROMPT\"] = 'think-reason-learn-py3.13' or os.path.basename(base)\n# add the virtual environments libraries to the host python import mechanism\nprev_length = len(sys.path)\nfor lib in '../lib/python3.13/site-packages'.split(os.pathsep):\n    path = os.path.realpath(os.path.join(bin_dir, lib))\n    site.addsitedir(path.decode(\"utf-8\") if '' else path)\nsys.path[:] = sys.path[prev_length:] + sys.path[0:prev_length]\nsys.real_prefix = sys.prefix\nsys.prefix = base",
        "detail": ".venv.bin.activate_this",
        "documentation": {}
    },
    {
        "label": "prev_length",
        "kind": 5,
        "importPath": ".venv.bin.activate_this",
        "description": ".venv.bin.activate_this",
        "peekOfCode": "prev_length = len(sys.path)\nfor lib in '../lib/python3.13/site-packages'.split(os.pathsep):\n    path = os.path.realpath(os.path.join(bin_dir, lib))\n    site.addsitedir(path.decode(\"utf-8\") if '' else path)\nsys.path[:] = sys.path[prev_length:] + sys.path[0:prev_length]\nsys.real_prefix = sys.prefix\nsys.prefix = base",
        "detail": ".venv.bin.activate_this",
        "documentation": {}
    },
    {
        "label": "sys.path[:]",
        "kind": 5,
        "importPath": ".venv.bin.activate_this",
        "description": ".venv.bin.activate_this",
        "peekOfCode": "sys.path[:] = sys.path[prev_length:] + sys.path[0:prev_length]\nsys.real_prefix = sys.prefix\nsys.prefix = base",
        "detail": ".venv.bin.activate_this",
        "documentation": {}
    },
    {
        "label": "sys.real_prefix",
        "kind": 5,
        "importPath": ".venv.bin.activate_this",
        "description": ".venv.bin.activate_this",
        "peekOfCode": "sys.real_prefix = sys.prefix\nsys.prefix = base",
        "detail": ".venv.bin.activate_this",
        "documentation": {}
    },
    {
        "label": "sys.prefix",
        "kind": 5,
        "importPath": ".venv.bin.activate_this",
        "description": ".venv.bin.activate_this",
        "peekOfCode": "sys.prefix = base",
        "detail": ".venv.bin.activate_this",
        "documentation": {}
    },
    {
        "label": "project",
        "kind": 5,
        "importPath": "docs.source.conf",
        "description": "docs.source.conf",
        "peekOfCode": "project = \"Think Reason Learn\"\ncopyright = \"2025, Vela Research\"\nauthor = \"Vela Research\"\nrelease = \"0.1.0\"\n# -- General configuration ---------------------------------------------------\n# https://www.sphinx-doc.org/en/master/usage/configuration.html#general-configuration\nextensions = [\n    \"sphinx.ext.autodoc\",\n    \"sphinx.ext.napoleon\",  # Google/NumPy style docstrings\n    \"myst_parser\",  # Enable Markdown with MyST",
        "detail": "docs.source.conf",
        "documentation": {}
    },
    {
        "label": "copyright",
        "kind": 5,
        "importPath": "docs.source.conf",
        "description": "docs.source.conf",
        "peekOfCode": "copyright = \"2025, Vela Research\"\nauthor = \"Vela Research\"\nrelease = \"0.1.0\"\n# -- General configuration ---------------------------------------------------\n# https://www.sphinx-doc.org/en/master/usage/configuration.html#general-configuration\nextensions = [\n    \"sphinx.ext.autodoc\",\n    \"sphinx.ext.napoleon\",  # Google/NumPy style docstrings\n    \"myst_parser\",  # Enable Markdown with MyST\n    \"sphinxcontrib.autodoc_pydantic\",  # Better Pydantic model rendering",
        "detail": "docs.source.conf",
        "documentation": {}
    },
    {
        "label": "author",
        "kind": 5,
        "importPath": "docs.source.conf",
        "description": "docs.source.conf",
        "peekOfCode": "author = \"Vela Research\"\nrelease = \"0.1.0\"\n# -- General configuration ---------------------------------------------------\n# https://www.sphinx-doc.org/en/master/usage/configuration.html#general-configuration\nextensions = [\n    \"sphinx.ext.autodoc\",\n    \"sphinx.ext.napoleon\",  # Google/NumPy style docstrings\n    \"myst_parser\",  # Enable Markdown with MyST\n    \"sphinxcontrib.autodoc_pydantic\",  # Better Pydantic model rendering\n]",
        "detail": "docs.source.conf",
        "documentation": {}
    },
    {
        "label": "release",
        "kind": 5,
        "importPath": "docs.source.conf",
        "description": "docs.source.conf",
        "peekOfCode": "release = \"0.1.0\"\n# -- General configuration ---------------------------------------------------\n# https://www.sphinx-doc.org/en/master/usage/configuration.html#general-configuration\nextensions = [\n    \"sphinx.ext.autodoc\",\n    \"sphinx.ext.napoleon\",  # Google/NumPy style docstrings\n    \"myst_parser\",  # Enable Markdown with MyST\n    \"sphinxcontrib.autodoc_pydantic\",  # Better Pydantic model rendering\n]\n# Make Sphinx include type hints alongside docstring descriptions",
        "detail": "docs.source.conf",
        "documentation": {}
    },
    {
        "label": "extensions",
        "kind": 5,
        "importPath": "docs.source.conf",
        "description": "docs.source.conf",
        "peekOfCode": "extensions = [\n    \"sphinx.ext.autodoc\",\n    \"sphinx.ext.napoleon\",  # Google/NumPy style docstrings\n    \"myst_parser\",  # Enable Markdown with MyST\n    \"sphinxcontrib.autodoc_pydantic\",  # Better Pydantic model rendering\n]\n# Make Sphinx include type hints alongside docstring descriptions\nautodoc_typehints = \"description\"  # merge types into the description\nautoclass_content = \"both\"  # include class and __init__ docstrings\nautodoc_member_order = \"bysource\"",
        "detail": "docs.source.conf",
        "documentation": {}
    },
    {
        "label": "autodoc_typehints",
        "kind": 5,
        "importPath": "docs.source.conf",
        "description": "docs.source.conf",
        "peekOfCode": "autodoc_typehints = \"description\"  # merge types into the description\nautoclass_content = \"both\"  # include class and __init__ docstrings\nautodoc_member_order = \"bysource\"\nadd_module_names = False  # cleaner object names in docs\nautodoc_default_options = {\n    \"members\": True,\n    \"undoc-members\": False,\n    \"inherited-members\": True,\n    \"show-inheritance\": True,\n    # Do not include imported members to reduce duplicates across re-exports",
        "detail": "docs.source.conf",
        "documentation": {}
    },
    {
        "label": "autoclass_content",
        "kind": 5,
        "importPath": "docs.source.conf",
        "description": "docs.source.conf",
        "peekOfCode": "autoclass_content = \"both\"  # include class and __init__ docstrings\nautodoc_member_order = \"bysource\"\nadd_module_names = False  # cleaner object names in docs\nautodoc_default_options = {\n    \"members\": True,\n    \"undoc-members\": False,\n    \"inherited-members\": True,\n    \"show-inheritance\": True,\n    # Do not include imported members to reduce duplicates across re-exports\n    \"imported-members\": False,",
        "detail": "docs.source.conf",
        "documentation": {}
    },
    {
        "label": "autodoc_member_order",
        "kind": 5,
        "importPath": "docs.source.conf",
        "description": "docs.source.conf",
        "peekOfCode": "autodoc_member_order = \"bysource\"\nadd_module_names = False  # cleaner object names in docs\nautodoc_default_options = {\n    \"members\": True,\n    \"undoc-members\": False,\n    \"inherited-members\": True,\n    \"show-inheritance\": True,\n    # Do not include imported members to reduce duplicates across re-exports\n    \"imported-members\": False,\n}",
        "detail": "docs.source.conf",
        "documentation": {}
    },
    {
        "label": "add_module_names",
        "kind": 5,
        "importPath": "docs.source.conf",
        "description": "docs.source.conf",
        "peekOfCode": "add_module_names = False  # cleaner object names in docs\nautodoc_default_options = {\n    \"members\": True,\n    \"undoc-members\": False,\n    \"inherited-members\": True,\n    \"show-inheritance\": True,\n    # Do not include imported members to reduce duplicates across re-exports\n    \"imported-members\": False,\n}\n# Napoleon settings for Google-style docstrings",
        "detail": "docs.source.conf",
        "documentation": {}
    },
    {
        "label": "autodoc_default_options",
        "kind": 5,
        "importPath": "docs.source.conf",
        "description": "docs.source.conf",
        "peekOfCode": "autodoc_default_options = {\n    \"members\": True,\n    \"undoc-members\": False,\n    \"inherited-members\": True,\n    \"show-inheritance\": True,\n    # Do not include imported members to reduce duplicates across re-exports\n    \"imported-members\": False,\n}\n# Napoleon settings for Google-style docstrings\nnapoleon_google_docstring = True",
        "detail": "docs.source.conf",
        "documentation": {}
    },
    {
        "label": "napoleon_google_docstring",
        "kind": 5,
        "importPath": "docs.source.conf",
        "description": "docs.source.conf",
        "peekOfCode": "napoleon_google_docstring = True\nnapoleon_attr_types = True  # Include type info in attributes\nnapoleon_preprocess_types = True  # Preprocess types for better rendering\nnapoleon_use_param = True  # Use :param: for parameters\nnapoleon_use_rtype = True  # Use :rtype: for return types\n# autodoc_pydantic settings to avoid duplication and combine fields\nautodoc_pydantic_model_show_json = False  # Hide JSON model if not needed\nautodoc_pydantic_model_show_config_summary = False  # Hide config\nautodoc_pydantic_model_member_order = \"bysource\"  # Order by source code\nautodoc_pydantic_field_list_style = \"compact\"  # Compact field lists",
        "detail": "docs.source.conf",
        "documentation": {}
    },
    {
        "label": "napoleon_attr_types",
        "kind": 5,
        "importPath": "docs.source.conf",
        "description": "docs.source.conf",
        "peekOfCode": "napoleon_attr_types = True  # Include type info in attributes\nnapoleon_preprocess_types = True  # Preprocess types for better rendering\nnapoleon_use_param = True  # Use :param: for parameters\nnapoleon_use_rtype = True  # Use :rtype: for return types\n# autodoc_pydantic settings to avoid duplication and combine fields\nautodoc_pydantic_model_show_json = False  # Hide JSON model if not needed\nautodoc_pydantic_model_show_config_summary = False  # Hide config\nautodoc_pydantic_model_member_order = \"bysource\"  # Order by source code\nautodoc_pydantic_field_list_style = \"compact\"  # Compact field lists\nautodoc_pydantic_field_doc_policy = \"description\"",
        "detail": "docs.source.conf",
        "documentation": {}
    },
    {
        "label": "napoleon_preprocess_types",
        "kind": 5,
        "importPath": "docs.source.conf",
        "description": "docs.source.conf",
        "peekOfCode": "napoleon_preprocess_types = True  # Preprocess types for better rendering\nnapoleon_use_param = True  # Use :param: for parameters\nnapoleon_use_rtype = True  # Use :rtype: for return types\n# autodoc_pydantic settings to avoid duplication and combine fields\nautodoc_pydantic_model_show_json = False  # Hide JSON model if not needed\nautodoc_pydantic_model_show_config_summary = False  # Hide config\nautodoc_pydantic_model_member_order = \"bysource\"  # Order by source code\nautodoc_pydantic_field_list_style = \"compact\"  # Compact field lists\nautodoc_pydantic_field_doc_policy = \"description\"\nautodoc_pydantic_model_show_field_summary = False  # Avoid duplicate field entries",
        "detail": "docs.source.conf",
        "documentation": {}
    },
    {
        "label": "napoleon_use_param",
        "kind": 5,
        "importPath": "docs.source.conf",
        "description": "docs.source.conf",
        "peekOfCode": "napoleon_use_param = True  # Use :param: for parameters\nnapoleon_use_rtype = True  # Use :rtype: for return types\n# autodoc_pydantic settings to avoid duplication and combine fields\nautodoc_pydantic_model_show_json = False  # Hide JSON model if not needed\nautodoc_pydantic_model_show_config_summary = False  # Hide config\nautodoc_pydantic_model_member_order = \"bysource\"  # Order by source code\nautodoc_pydantic_field_list_style = \"compact\"  # Compact field lists\nautodoc_pydantic_field_doc_policy = \"description\"\nautodoc_pydantic_model_show_field_summary = False  # Avoid duplicate field entries\ntemplates_path = [\"_templates\"]",
        "detail": "docs.source.conf",
        "documentation": {}
    },
    {
        "label": "napoleon_use_rtype",
        "kind": 5,
        "importPath": "docs.source.conf",
        "description": "docs.source.conf",
        "peekOfCode": "napoleon_use_rtype = True  # Use :rtype: for return types\n# autodoc_pydantic settings to avoid duplication and combine fields\nautodoc_pydantic_model_show_json = False  # Hide JSON model if not needed\nautodoc_pydantic_model_show_config_summary = False  # Hide config\nautodoc_pydantic_model_member_order = \"bysource\"  # Order by source code\nautodoc_pydantic_field_list_style = \"compact\"  # Compact field lists\nautodoc_pydantic_field_doc_policy = \"description\"\nautodoc_pydantic_model_show_field_summary = False  # Avoid duplicate field entries\ntemplates_path = [\"_templates\"]\nexclude_patterns = []",
        "detail": "docs.source.conf",
        "documentation": {}
    },
    {
        "label": "autodoc_pydantic_model_show_json",
        "kind": 5,
        "importPath": "docs.source.conf",
        "description": "docs.source.conf",
        "peekOfCode": "autodoc_pydantic_model_show_json = False  # Hide JSON model if not needed\nautodoc_pydantic_model_show_config_summary = False  # Hide config\nautodoc_pydantic_model_member_order = \"bysource\"  # Order by source code\nautodoc_pydantic_field_list_style = \"compact\"  # Compact field lists\nautodoc_pydantic_field_doc_policy = \"description\"\nautodoc_pydantic_model_show_field_summary = False  # Avoid duplicate field entries\ntemplates_path = [\"_templates\"]\nexclude_patterns = []\n# Allow both .rst and .md files\nsource_suffix = {",
        "detail": "docs.source.conf",
        "documentation": {}
    },
    {
        "label": "autodoc_pydantic_model_show_config_summary",
        "kind": 5,
        "importPath": "docs.source.conf",
        "description": "docs.source.conf",
        "peekOfCode": "autodoc_pydantic_model_show_config_summary = False  # Hide config\nautodoc_pydantic_model_member_order = \"bysource\"  # Order by source code\nautodoc_pydantic_field_list_style = \"compact\"  # Compact field lists\nautodoc_pydantic_field_doc_policy = \"description\"\nautodoc_pydantic_model_show_field_summary = False  # Avoid duplicate field entries\ntemplates_path = [\"_templates\"]\nexclude_patterns = []\n# Allow both .rst and .md files\nsource_suffix = {\n    \".rst\": \"restructuredtext\",",
        "detail": "docs.source.conf",
        "documentation": {}
    },
    {
        "label": "autodoc_pydantic_model_member_order",
        "kind": 5,
        "importPath": "docs.source.conf",
        "description": "docs.source.conf",
        "peekOfCode": "autodoc_pydantic_model_member_order = \"bysource\"  # Order by source code\nautodoc_pydantic_field_list_style = \"compact\"  # Compact field lists\nautodoc_pydantic_field_doc_policy = \"description\"\nautodoc_pydantic_model_show_field_summary = False  # Avoid duplicate field entries\ntemplates_path = [\"_templates\"]\nexclude_patterns = []\n# Allow both .rst and .md files\nsource_suffix = {\n    \".rst\": \"restructuredtext\",\n    \".md\": \"markdown\",",
        "detail": "docs.source.conf",
        "documentation": {}
    },
    {
        "label": "autodoc_pydantic_field_list_style",
        "kind": 5,
        "importPath": "docs.source.conf",
        "description": "docs.source.conf",
        "peekOfCode": "autodoc_pydantic_field_list_style = \"compact\"  # Compact field lists\nautodoc_pydantic_field_doc_policy = \"description\"\nautodoc_pydantic_model_show_field_summary = False  # Avoid duplicate field entries\ntemplates_path = [\"_templates\"]\nexclude_patterns = []\n# Allow both .rst and .md files\nsource_suffix = {\n    \".rst\": \"restructuredtext\",\n    \".md\": \"markdown\",\n}",
        "detail": "docs.source.conf",
        "documentation": {}
    },
    {
        "label": "autodoc_pydantic_field_doc_policy",
        "kind": 5,
        "importPath": "docs.source.conf",
        "description": "docs.source.conf",
        "peekOfCode": "autodoc_pydantic_field_doc_policy = \"description\"\nautodoc_pydantic_model_show_field_summary = False  # Avoid duplicate field entries\ntemplates_path = [\"_templates\"]\nexclude_patterns = []\n# Allow both .rst and .md files\nsource_suffix = {\n    \".rst\": \"restructuredtext\",\n    \".md\": \"markdown\",\n}\n# -- Options for HTML output -------------------------------------------------",
        "detail": "docs.source.conf",
        "documentation": {}
    },
    {
        "label": "autodoc_pydantic_model_show_field_summary",
        "kind": 5,
        "importPath": "docs.source.conf",
        "description": "docs.source.conf",
        "peekOfCode": "autodoc_pydantic_model_show_field_summary = False  # Avoid duplicate field entries\ntemplates_path = [\"_templates\"]\nexclude_patterns = []\n# Allow both .rst and .md files\nsource_suffix = {\n    \".rst\": \"restructuredtext\",\n    \".md\": \"markdown\",\n}\n# -- Options for HTML output -------------------------------------------------\n# https://www.sphinx-doc.org/en/master/usage/configuration.html#options-for-html-output",
        "detail": "docs.source.conf",
        "documentation": {}
    },
    {
        "label": "templates_path",
        "kind": 5,
        "importPath": "docs.source.conf",
        "description": "docs.source.conf",
        "peekOfCode": "templates_path = [\"_templates\"]\nexclude_patterns = []\n# Allow both .rst and .md files\nsource_suffix = {\n    \".rst\": \"restructuredtext\",\n    \".md\": \"markdown\",\n}\n# -- Options for HTML output -------------------------------------------------\n# https://www.sphinx-doc.org/en/master/usage/configuration.html#options-for-html-output\n# Furo theme options (optional cosmetics)",
        "detail": "docs.source.conf",
        "documentation": {}
    },
    {
        "label": "exclude_patterns",
        "kind": 5,
        "importPath": "docs.source.conf",
        "description": "docs.source.conf",
        "peekOfCode": "exclude_patterns = []\n# Allow both .rst and .md files\nsource_suffix = {\n    \".rst\": \"restructuredtext\",\n    \".md\": \"markdown\",\n}\n# -- Options for HTML output -------------------------------------------------\n# https://www.sphinx-doc.org/en/master/usage/configuration.html#options-for-html-output\n# Furo theme options (optional cosmetics)\nhtml_theme = \"furo\"  # Modern, responsive theme (pip install furo)",
        "detail": "docs.source.conf",
        "documentation": {}
    },
    {
        "label": "source_suffix",
        "kind": 5,
        "importPath": "docs.source.conf",
        "description": "docs.source.conf",
        "peekOfCode": "source_suffix = {\n    \".rst\": \"restructuredtext\",\n    \".md\": \"markdown\",\n}\n# -- Options for HTML output -------------------------------------------------\n# https://www.sphinx-doc.org/en/master/usage/configuration.html#options-for-html-output\n# Furo theme options (optional cosmetics)\nhtml_theme = \"furo\"  # Modern, responsive theme (pip install furo)\nhtml_static_path = [\"_static\"]\nhtml_title = \"Think Reason Learn\"",
        "detail": "docs.source.conf",
        "documentation": {}
    },
    {
        "label": "html_theme",
        "kind": 5,
        "importPath": "docs.source.conf",
        "description": "docs.source.conf",
        "peekOfCode": "html_theme = \"furo\"  # Modern, responsive theme (pip install furo)\nhtml_static_path = [\"_static\"]\nhtml_title = \"Think Reason Learn\"\nhtml_short_title = \"TRL\"\nhtml_theme_options = {\n    \"light_css_variables\": {\n        \"color-brand-primary\": \"#2e7d32\",\n        \"color-brand-content\": \"#1b5e20\",\n    },\n    \"footer_icons\": [",
        "detail": "docs.source.conf",
        "documentation": {}
    },
    {
        "label": "html_static_path",
        "kind": 5,
        "importPath": "docs.source.conf",
        "description": "docs.source.conf",
        "peekOfCode": "html_static_path = [\"_static\"]\nhtml_title = \"Think Reason Learn\"\nhtml_short_title = \"TRL\"\nhtml_theme_options = {\n    \"light_css_variables\": {\n        \"color-brand-primary\": \"#2e7d32\",\n        \"color-brand-content\": \"#1b5e20\",\n    },\n    \"footer_icons\": [\n        {",
        "detail": "docs.source.conf",
        "documentation": {}
    },
    {
        "label": "html_title",
        "kind": 5,
        "importPath": "docs.source.conf",
        "description": "docs.source.conf",
        "peekOfCode": "html_title = \"Think Reason Learn\"\nhtml_short_title = \"TRL\"\nhtml_theme_options = {\n    \"light_css_variables\": {\n        \"color-brand-primary\": \"#2e7d32\",\n        \"color-brand-content\": \"#1b5e20\",\n    },\n    \"footer_icons\": [\n        {\n            \"name\": \"GitHub\",",
        "detail": "docs.source.conf",
        "documentation": {}
    },
    {
        "label": "html_short_title",
        "kind": 5,
        "importPath": "docs.source.conf",
        "description": "docs.source.conf",
        "peekOfCode": "html_short_title = \"TRL\"\nhtml_theme_options = {\n    \"light_css_variables\": {\n        \"color-brand-primary\": \"#2e7d32\",\n        \"color-brand-content\": \"#1b5e20\",\n    },\n    \"footer_icons\": [\n        {\n            \"name\": \"GitHub\",\n            \"url\": \"https://github.com/vela-research/think-reason-learn\",",
        "detail": "docs.source.conf",
        "documentation": {}
    },
    {
        "label": "html_theme_options",
        "kind": 5,
        "importPath": "docs.source.conf",
        "description": "docs.source.conf",
        "peekOfCode": "html_theme_options = {\n    \"light_css_variables\": {\n        \"color-brand-primary\": \"#2e7d32\",\n        \"color-brand-content\": \"#1b5e20\",\n    },\n    \"footer_icons\": [\n        {\n            \"name\": \"GitHub\",\n            \"url\": \"https://github.com/vela-research/think-reason-learn\",\n            \"html\": (",
        "detail": "docs.source.conf",
        "documentation": {}
    },
    {
        "label": "PROJECT_ROOT",
        "kind": 5,
        "importPath": "tests.conftest",
        "description": "tests.conftest",
        "peekOfCode": "PROJECT_ROOT = Path(__file__).resolve().parents[1]\nif str(PROJECT_ROOT) not in sys.path:\n    sys.path.insert(0, str(PROJECT_ROOT))",
        "detail": "tests.conftest",
        "documentation": {}
    },
    {
        "label": "test_placeholder",
        "kind": 2,
        "importPath": "tests.test_placeholder",
        "description": "tests.test_placeholder",
        "peekOfCode": "def test_placeholder():\n    \"\"\"Test the placeholder test.\"\"\"\n    assert True",
        "detail": "tests.test_placeholder",
        "documentation": {}
    },
    {
        "label": "AnthropicInput",
        "kind": 6,
        "importPath": "think_reason_learn.core.llms._anthropic.ask",
        "description": "think_reason_learn.core.llms._anthropic.ask",
        "peekOfCode": "class AnthropicInput(TypedDict):\n    messages: List[MessageParam]\n    system: str | Iterable[TextBlockParam] | NotGiven\n    tools: List[ToolUnionParam] | NotGiven\n    tool_choice: ToolChoiceParam | NotGiven\n    temperature: float | NotGiven\n    kwargs: Dict[str, Any]\nclass AnthropicLLM(metaclass=SingletonMeta):\n    def __init__(self, api_key: str) -> None:\n        self.client = anthropic.Anthropic(api_key=api_key)",
        "detail": "think_reason_learn.core.llms._anthropic.ask",
        "documentation": {}
    },
    {
        "label": "AnthropicLLM",
        "kind": 6,
        "importPath": "think_reason_learn.core.llms._anthropic.ask",
        "description": "think_reason_learn.core.llms._anthropic.ask",
        "peekOfCode": "class AnthropicLLM(metaclass=SingletonMeta):\n    def __init__(self, api_key: str) -> None:\n        self.client = anthropic.Anthropic(api_key=api_key)\n        self.aclient = anthropic.AsyncAnthropic(api_key=api_key)\n    def _process_input(\n        self,\n        query: str,\n        response_format: Type[T],\n        instructions: str | NotGiven,\n        temperature: float | NotGiven,",
        "detail": "think_reason_learn.core.llms._anthropic.ask",
        "documentation": {}
    },
    {
        "label": "get_anthropic_llm",
        "kind": 2,
        "importPath": "think_reason_learn.core.llms._anthropic.ask",
        "description": "think_reason_learn.core.llms._anthropic.ask",
        "peekOfCode": "def get_anthropic_llm(api_key: str) -> AnthropicLLM | None:\n    return AnthropicLLM(api_key) if api_key else None",
        "detail": "think_reason_learn.core.llms._anthropic.ask",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "think_reason_learn.core.llms._anthropic.ask",
        "description": "think_reason_learn.core.llms._anthropic.ask",
        "peekOfCode": "logger = logging.getLogger(__name__)\nDEFAULT_MAX_TOKENS = 4096\nclass AnthropicInput(TypedDict):\n    messages: List[MessageParam]\n    system: str | Iterable[TextBlockParam] | NotGiven\n    tools: List[ToolUnionParam] | NotGiven\n    tool_choice: ToolChoiceParam | NotGiven\n    temperature: float | NotGiven\n    kwargs: Dict[str, Any]\nclass AnthropicLLM(metaclass=SingletonMeta):",
        "detail": "think_reason_learn.core.llms._anthropic.ask",
        "documentation": {}
    },
    {
        "label": "DEFAULT_MAX_TOKENS",
        "kind": 5,
        "importPath": "think_reason_learn.core.llms._anthropic.ask",
        "description": "think_reason_learn.core.llms._anthropic.ask",
        "peekOfCode": "DEFAULT_MAX_TOKENS = 4096\nclass AnthropicInput(TypedDict):\n    messages: List[MessageParam]\n    system: str | Iterable[TextBlockParam] | NotGiven\n    tools: List[ToolUnionParam] | NotGiven\n    tool_choice: ToolChoiceParam | NotGiven\n    temperature: float | NotGiven\n    kwargs: Dict[str, Any]\nclass AnthropicLLM(metaclass=SingletonMeta):\n    def __init__(self, api_key: str) -> None:",
        "detail": "think_reason_learn.core.llms._anthropic.ask",
        "documentation": {}
    },
    {
        "label": "AnthropicChoice",
        "kind": 6,
        "importPath": "think_reason_learn.core.llms._anthropic.schemas",
        "description": "think_reason_learn.core.llms._anthropic.schemas",
        "peekOfCode": "class AnthropicChoice(BaseModel):\n    \"\"\"An LLM from Anthropic.\"\"\"\n    provider: Literal[\"anthropic\"] = \"anthropic\"\n    model: AnthropicChatModel\nclass AnthropicChoiceDict(TypedDict):\n    \"\"\"An LLM from Anthropic.\"\"\"\n    provider: Literal[\"anthropic\"]\n    model: AnthropicChatModel",
        "detail": "think_reason_learn.core.llms._anthropic.schemas",
        "documentation": {}
    },
    {
        "label": "AnthropicChoiceDict",
        "kind": 6,
        "importPath": "think_reason_learn.core.llms._anthropic.schemas",
        "description": "think_reason_learn.core.llms._anthropic.schemas",
        "peekOfCode": "class AnthropicChoiceDict(TypedDict):\n    \"\"\"An LLM from Anthropic.\"\"\"\n    provider: Literal[\"anthropic\"]\n    model: AnthropicChatModel",
        "detail": "think_reason_learn.core.llms._anthropic.schemas",
        "documentation": {}
    },
    {
        "label": "GeminiLLM",
        "kind": 6,
        "importPath": "think_reason_learn.core.llms._google.ask",
        "description": "think_reason_learn.core.llms._google.ask",
        "peekOfCode": "class GeminiLLM(metaclass=SingletonMeta):\n    def __init__(self, api_key: str) -> None:\n        self.client = genai.Client(api_key=api_key)\n    def _process_kwargs(\n        self,\n        kwargs: Dict[str, Any],\n    ) -> Dict[str, Any]:\n        \"\"\"Process Google kwargs and query.\"\"\"\n        return {\n            k: v or None",
        "detail": "think_reason_learn.core.llms._google.ask",
        "documentation": {}
    },
    {
        "label": "get_google_llm",
        "kind": 2,
        "importPath": "think_reason_learn.core.llms._google.ask",
        "description": "think_reason_learn.core.llms._google.ask",
        "peekOfCode": "def get_google_llm(api_key: str) -> GeminiLLM | None:\n    return GeminiLLM(api_key) if api_key else None",
        "detail": "think_reason_learn.core.llms._google.ask",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "think_reason_learn.core.llms._google.ask",
        "description": "think_reason_learn.core.llms._google.ask",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass GeminiLLM(metaclass=SingletonMeta):\n    def __init__(self, api_key: str) -> None:\n        self.client = genai.Client(api_key=api_key)\n    def _process_kwargs(\n        self,\n        kwargs: Dict[str, Any],\n    ) -> Dict[str, Any]:\n        \"\"\"Process Google kwargs and query.\"\"\"\n        return {",
        "detail": "think_reason_learn.core.llms._google.ask",
        "documentation": {}
    },
    {
        "label": "GoogleChoice",
        "kind": 6,
        "importPath": "think_reason_learn.core.llms._google.schemas",
        "description": "think_reason_learn.core.llms._google.schemas",
        "peekOfCode": "class GoogleChoice(BaseModel):\n    \"\"\"An LLM from Google.\"\"\"\n    provider: Literal[\"google\"] = \"google\"\n    model: GoogleChatModel\nclass GoogleChoiceDict(TypedDict):\n    \"\"\"An LLM from Google.\"\"\"\n    provider: Literal[\"google\"]\n    model: GoogleChatModel",
        "detail": "think_reason_learn.core.llms._google.schemas",
        "documentation": {}
    },
    {
        "label": "GoogleChoiceDict",
        "kind": 6,
        "importPath": "think_reason_learn.core.llms._google.schemas",
        "description": "think_reason_learn.core.llms._google.schemas",
        "peekOfCode": "class GoogleChoiceDict(TypedDict):\n    \"\"\"An LLM from Google.\"\"\"\n    provider: Literal[\"google\"]\n    model: GoogleChatModel",
        "detail": "think_reason_learn.core.llms._google.schemas",
        "documentation": {}
    },
    {
        "label": "OpenAILLM",
        "kind": 6,
        "importPath": "think_reason_learn.core.llms._openai.ask",
        "description": "think_reason_learn.core.llms._openai.ask",
        "peekOfCode": "class OpenAILLM(metaclass=SingletonMeta):\n    def __init__(self, api_key: str) -> None:\n        self.client = OpenAI(api_key=api_key)\n        self.aclient = AsyncOpenAI(api_key=api_key)\n    def _process_kwargs(self, kwargs: Dict[str, Any]) -> Dict[str, Any]:\n        return {\n            k: v if v else (None if v is None else NOT_GIVEN)\n            for k, v in kwargs.items()\n            if k in self.client.responses.parse.__annotations__\n        }",
        "detail": "think_reason_learn.core.llms._openai.ask",
        "documentation": {}
    },
    {
        "label": "get_openai_llm",
        "kind": 2,
        "importPath": "think_reason_learn.core.llms._openai.ask",
        "description": "think_reason_learn.core.llms._openai.ask",
        "peekOfCode": "def get_openai_llm(api_key: str) -> OpenAILLM | None:\n    return OpenAILLM(api_key) if api_key else None",
        "detail": "think_reason_learn.core.llms._openai.ask",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "think_reason_learn.core.llms._openai.ask",
        "description": "think_reason_learn.core.llms._openai.ask",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass OpenAILLM(metaclass=SingletonMeta):\n    def __init__(self, api_key: str) -> None:\n        self.client = OpenAI(api_key=api_key)\n        self.aclient = AsyncOpenAI(api_key=api_key)\n    def _process_kwargs(self, kwargs: Dict[str, Any]) -> Dict[str, Any]:\n        return {\n            k: v if v else (None if v is None else NOT_GIVEN)\n            for k, v in kwargs.items()\n            if k in self.client.responses.parse.__annotations__",
        "detail": "think_reason_learn.core.llms._openai.ask",
        "documentation": {}
    },
    {
        "label": "OpenAIChoice",
        "kind": 6,
        "importPath": "think_reason_learn.core.llms._openai.schemas",
        "description": "think_reason_learn.core.llms._openai.schemas",
        "peekOfCode": "class OpenAIChoice(BaseModel):\n    \"\"\"An LLM from OpenAI.\"\"\"\n    provider: Literal[\"openai\"] = \"openai\"\n    model: OpenAIChatModel\nclass OpenAIChoiceDict(TypedDict):\n    \"\"\"An LLM from OpenAI.\"\"\"\n    provider: Literal[\"openai\"]\n    model: OpenAIChatModel",
        "detail": "think_reason_learn.core.llms._openai.schemas",
        "documentation": {}
    },
    {
        "label": "OpenAIChoiceDict",
        "kind": 6,
        "importPath": "think_reason_learn.core.llms._openai.schemas",
        "description": "think_reason_learn.core.llms._openai.schemas",
        "peekOfCode": "class OpenAIChoiceDict(TypedDict):\n    \"\"\"An LLM from OpenAI.\"\"\"\n    provider: Literal[\"openai\"]\n    model: OpenAIChatModel",
        "detail": "think_reason_learn.core.llms._openai.schemas",
        "documentation": {}
    },
    {
        "label": "xAILLM",
        "kind": 6,
        "importPath": "think_reason_learn.core.llms._xai.ask",
        "description": "think_reason_learn.core.llms._xai.ask",
        "peekOfCode": "class xAILLM(metaclass=SingletonMeta):\n    def __init__(self, api_key: str) -> None:\n        self.client = Client(api_key=api_key)\n        self.aclient = AsyncClient(api_key=api_key)\n    def _process_kwargs(self, kwargs: Dict[str, Any]) -> Dict[str, Any]:\n        return {\n            k: v or None\n            for k, v in kwargs.items()\n            if k in self.client.chat.create.__annotations__\n        }",
        "detail": "think_reason_learn.core.llms._xai.ask",
        "documentation": {}
    },
    {
        "label": "get_xai_llm",
        "kind": 2,
        "importPath": "think_reason_learn.core.llms._xai.ask",
        "description": "think_reason_learn.core.llms._xai.ask",
        "peekOfCode": "def get_xai_llm(api_key: str) -> xAILLM | None:\n    return xAILLM(api_key) if api_key else None",
        "detail": "think_reason_learn.core.llms._xai.ask",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "think_reason_learn.core.llms._xai.ask",
        "description": "think_reason_learn.core.llms._xai.ask",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass xAILLM(metaclass=SingletonMeta):\n    def __init__(self, api_key: str) -> None:\n        self.client = Client(api_key=api_key)\n        self.aclient = AsyncClient(api_key=api_key)\n    def _process_kwargs(self, kwargs: Dict[str, Any]) -> Dict[str, Any]:\n        return {\n            k: v or None\n            for k, v in kwargs.items()\n            if k in self.client.chat.create.__annotations__",
        "detail": "think_reason_learn.core.llms._xai.ask",
        "documentation": {}
    },
    {
        "label": "XAIChoice",
        "kind": 6,
        "importPath": "think_reason_learn.core.llms._xai.schemas",
        "description": "think_reason_learn.core.llms._xai.schemas",
        "peekOfCode": "class XAIChoice(BaseModel):\n    \"\"\"An LLM from XAI.\"\"\"\n    provider: Literal[\"xai\"] = \"xai\"\n    model: xAIChatModel\nclass XAIChoiceDict(TypedDict):\n    \"\"\"An LLM from XAI.\"\"\"\n    provider: Literal[\"xai\"]\n    model: xAIChatModel",
        "detail": "think_reason_learn.core.llms._xai.schemas",
        "documentation": {}
    },
    {
        "label": "XAIChoiceDict",
        "kind": 6,
        "importPath": "think_reason_learn.core.llms._xai.schemas",
        "description": "think_reason_learn.core.llms._xai.schemas",
        "peekOfCode": "class XAIChoiceDict(TypedDict):\n    \"\"\"An LLM from XAI.\"\"\"\n    provider: Literal[\"xai\"]\n    model: xAIChatModel",
        "detail": "think_reason_learn.core.llms._xai.schemas",
        "documentation": {}
    },
    {
        "label": "LLM",
        "kind": 6,
        "importPath": "think_reason_learn.core.llms._ask",
        "description": "think_reason_learn.core.llms._ask",
        "peekOfCode": "class LLM(metaclass=SingletonMeta):\n    \"\"\"A singleton class that provides a unified interface for the LLMs.\"\"\"\n    def __init__(self) -> None:\n        self.anthropic_llm = get_anthropic_llm(settings.ANTHROPIC_API_KEY)\n        self.google_llm = get_google_llm(settings.GOOGLE_AI_API_KEY)\n        self.openai_llm = get_openai_llm(settings.OPENAI_API_KEY)\n        self.xai_llm = get_xai_llm(settings.XAI_API_KEY)\n    def _val_llm_priority_and_api_keys(\n        self, llm_priority: List[LLMChoice]\n    ) -> List[LLMChoiceModel]:",
        "detail": "think_reason_learn.core.llms._ask",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "think_reason_learn.core.llms._ask",
        "description": "think_reason_learn.core.llms._ask",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass LLM(metaclass=SingletonMeta):\n    \"\"\"A singleton class that provides a unified interface for the LLMs.\"\"\"\n    def __init__(self) -> None:\n        self.anthropic_llm = get_anthropic_llm(settings.ANTHROPIC_API_KEY)\n        self.google_llm = get_google_llm(settings.GOOGLE_AI_API_KEY)\n        self.openai_llm = get_openai_llm(settings.OPENAI_API_KEY)\n        self.xai_llm = get_xai_llm(settings.XAI_API_KEY)\n    def _val_llm_priority_and_api_keys(\n        self, llm_priority: List[LLMChoice]",
        "detail": "think_reason_learn.core.llms._ask",
        "documentation": {}
    },
    {
        "label": "LLMResponse",
        "kind": 6,
        "importPath": "think_reason_learn.core.llms._schemas",
        "description": "think_reason_learn.core.llms._schemas",
        "peekOfCode": "class LLMResponse(BaseModel, Generic[T]):\n    \"\"\"A response from an LLM.\"\"\"\n    response: T | None = Field(default=None, description=\"The response from the LLM.\")\n    logprobs: List[Tuple[str, float | None]] = Field(\n        description=\"The log probabilities of the response.\"\n    )\n    total_tokens: int | None = Field(\n        default=None,\n        description=\"The total number of input and output tokens used \"\n        \"to generate the response.\",",
        "detail": "think_reason_learn.core.llms._schemas",
        "documentation": {}
    },
    {
        "label": "NotGiven",
        "kind": 6,
        "importPath": "think_reason_learn.core.llms._schemas",
        "description": "think_reason_learn.core.llms._schemas",
        "peekOfCode": "class NotGiven:\n    \"\"\"A sentinel singleton class used to distinguish omitted keyword arguments.\n    Examples:\n        .. code-block:: python\n            def get(timeout: int | NotGiven | None = NotGiven()) -> Response: ...\n            get(timeout=1)      # 1s timeout\n            get(timeout=None)   # No timeout\n            get()               # Default timeout behavior; may not be statically\n                                # known at the method definition.\n    \"\"\"",
        "detail": "think_reason_learn.core.llms._schemas",
        "documentation": {}
    },
    {
        "label": "TokenCount",
        "kind": 6,
        "importPath": "think_reason_learn.core.llms._schemas",
        "description": "think_reason_learn.core.llms._schemas",
        "peekOfCode": "class TokenCount:\n    \"\"\"A token count from an LLM.\"\"\"\n    provider: LLMProvider = field(metadata={\"description\": \"The provider of the LLM.\"})\n    model: LLMChatModel = field(metadata={\"description\": \"The LLM model used.\"})\n    value: int | None = field(\n        default=None, metadata={\"description\": \"The token count.\"}\n    )",
        "detail": "think_reason_learn.core.llms._schemas",
        "documentation": {}
    },
    {
        "label": "T",
        "kind": 5,
        "importPath": "think_reason_learn.core.llms._schemas",
        "description": "think_reason_learn.core.llms._schemas",
        "peekOfCode": "T = TypeVar(\"T\", bound=BaseModel | str, covariant=True)\nLLMProvider: TypeAlias = Literal[\"anthropic\", \"google\", \"openai\", \"xai\"]\nLLMChatModel: TypeAlias = Union[\n    AnthropicChatModel,\n    GoogleChatModel,\n    OpenAIChatModel,\n    xAIChatModel,\n]\nLLMChoiceModel: TypeAlias = Union[\n    AnthropicChoice,",
        "detail": "think_reason_learn.core.llms._schemas",
        "documentation": {}
    },
    {
        "label": "NOT_GIVEN",
        "kind": 5,
        "importPath": "think_reason_learn.core.llms._schemas",
        "description": "think_reason_learn.core.llms._schemas",
        "peekOfCode": "NOT_GIVEN = NotGiven()\n@dataclass(slots=True)\nclass TokenCount:\n    \"\"\"A token count from an LLM.\"\"\"\n    provider: LLMProvider = field(metadata={\"description\": \"The provider of the LLM.\"})\n    model: LLMChatModel = field(metadata={\"description\": \"The LLM model used.\"})\n    value: int | None = field(\n        default=None, metadata={\"description\": \"The token count.\"}\n    )",
        "detail": "think_reason_learn.core.llms._schemas",
        "documentation": {}
    },
    {
        "label": "Settings",
        "kind": 6,
        "importPath": "think_reason_learn.core._config",
        "description": "think_reason_learn.core._config",
        "peekOfCode": "class Settings(BaseSettings):\n    \"\"\"Class to store all the settings of the application.\"\"\"\n    OPENAI_API_KEY: str = \"\"\n    GOOGLE_AI_API_KEY: str = \"\"\n    XAI_API_KEY: str = \"\"\n    ANTHROPIC_API_KEY: str = \"\"\n    model_config = SettingsConfigDict(\n        case_sensitive=False,\n        env_file=\".env\",\n        env_file_encoding=\"utf-8\",",
        "detail": "think_reason_learn.core._config",
        "documentation": {}
    },
    {
        "label": "settings",
        "kind": 5,
        "importPath": "think_reason_learn.core._config",
        "description": "think_reason_learn.core._config",
        "peekOfCode": "settings = Settings()  # type: ignore",
        "detail": "think_reason_learn.core._config",
        "documentation": {}
    },
    {
        "label": "DataError",
        "kind": 6,
        "importPath": "think_reason_learn.core._exceptions",
        "description": "think_reason_learn.core._exceptions",
        "peekOfCode": "class DataError(Exception):\n    \"\"\"Data not in the expected format.\"\"\"\nclass LLMError(Exception):\n    \"\"\"LLM failed to respond.\"\"\"\nclass CorruptionError(Exception):\n    \"\"\"Internal state corruption detected. A model's state is corrupted.\"\"\"",
        "detail": "think_reason_learn.core._exceptions",
        "documentation": {}
    },
    {
        "label": "LLMError",
        "kind": 6,
        "importPath": "think_reason_learn.core._exceptions",
        "description": "think_reason_learn.core._exceptions",
        "peekOfCode": "class LLMError(Exception):\n    \"\"\"LLM failed to respond.\"\"\"\nclass CorruptionError(Exception):\n    \"\"\"Internal state corruption detected. A model's state is corrupted.\"\"\"",
        "detail": "think_reason_learn.core._exceptions",
        "documentation": {}
    },
    {
        "label": "CorruptionError",
        "kind": 6,
        "importPath": "think_reason_learn.core._exceptions",
        "description": "think_reason_learn.core._exceptions",
        "peekOfCode": "class CorruptionError(Exception):\n    \"\"\"Internal state corruption detected. A model's state is corrupted.\"\"\"",
        "detail": "think_reason_learn.core._exceptions",
        "documentation": {}
    },
    {
        "label": "SingletonMeta",
        "kind": 6,
        "importPath": "think_reason_learn.core._singleton",
        "description": "think_reason_learn.core._singleton",
        "peekOfCode": "class SingletonMeta(type):\n    _instances: ClassVar[Dict[type, object]] = {}\n    def __call__(cls: type[T], *args: Any, **kwargs: Any) -> T:\n        if cls not in cls._instances:  # type: ignore\n            cls._instances[cls] = super().__call__(*args, **kwargs)  # type: ignore\n        return cls._instances[cls]  # type: ignore\n__all__ = [\"SingletonMeta\"]",
        "detail": "think_reason_learn.core._singleton",
        "documentation": {}
    },
    {
        "label": "T",
        "kind": 5,
        "importPath": "think_reason_learn.core._singleton",
        "description": "think_reason_learn.core._singleton",
        "peekOfCode": "T = TypeVar(\"T\")\nclass SingletonMeta(type):\n    _instances: ClassVar[Dict[type, object]] = {}\n    def __call__(cls: type[T], *args: Any, **kwargs: Any) -> T:\n        if cls not in cls._instances:  # type: ignore\n            cls._instances[cls] = super().__call__(*args, **kwargs)  # type: ignore\n        return cls._instances[cls]  # type: ignore\n__all__ = [\"SingletonMeta\"]",
        "detail": "think_reason_learn.core._singleton",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "think_reason_learn.core._singleton",
        "description": "think_reason_learn.core._singleton",
        "peekOfCode": "__all__ = [\"SingletonMeta\"]",
        "detail": "think_reason_learn.core._singleton",
        "documentation": {}
    },
    {
        "label": "JSONScalar",
        "kind": 5,
        "importPath": "think_reason_learn.core._types",
        "description": "think_reason_learn.core._types",
        "peekOfCode": "JSONScalar = Union[str, int, float, bool, None]\nJSONValue = Union[JSONScalar, Dict[str, \"JSONValue\"], List[\"JSONValue\"]]",
        "detail": "think_reason_learn.core._types",
        "documentation": {}
    },
    {
        "label": "JSONValue",
        "kind": 5,
        "importPath": "think_reason_learn.core._types",
        "description": "think_reason_learn.core._types",
        "peekOfCode": "JSONValue = Union[JSONScalar, Dict[str, \"JSONValue\"], List[\"JSONValue\"]]",
        "detail": "think_reason_learn.core._types",
        "documentation": {}
    },
    {
        "label": "NodeQuestion",
        "kind": 6,
        "importPath": "think_reason_learn.gptree._gptree",
        "description": "think_reason_learn.gptree._gptree",
        "peekOfCode": "class NodeQuestion:\n    \"\"\"A question for generated at a node.\"\"\"\n    value: str = field(metadata={\"description\": \"The question text.\"})\n    choices: List[str] = field(\n        metadata={\"description\": \"The answer choices for the question.\"}\n    )\n    question_type: QuestionType = field(\n        metadata={\"description\": \"The type of the question.\"}\n    )\n    df_column: str = field(",
        "detail": "think_reason_learn.gptree._gptree",
        "documentation": {}
    },
    {
        "label": "Question",
        "kind": 6,
        "importPath": "think_reason_learn.gptree._gptree",
        "description": "think_reason_learn.gptree._gptree",
        "peekOfCode": "class Question(BaseModel):\n    value: str\n    choices: List[str]\n    question_type: QuestionType\nclass Questions(BaseModel):\n    questions: List[Question]\n    cumulative_memory: str = Field(..., description=CUMULATIVE_MEMORY_INSTRUCTIONS)\nclass Answer(BaseModel):\n    answer: str\n@dataclass(slots=True)",
        "detail": "think_reason_learn.gptree._gptree",
        "documentation": {}
    },
    {
        "label": "Questions",
        "kind": 6,
        "importPath": "think_reason_learn.gptree._gptree",
        "description": "think_reason_learn.gptree._gptree",
        "peekOfCode": "class Questions(BaseModel):\n    questions: List[Question]\n    cumulative_memory: str = Field(..., description=CUMULATIVE_MEMORY_INSTRUCTIONS)\nclass Answer(BaseModel):\n    answer: str\n@dataclass(slots=True)\nclass Node:\n    \"\"\"A Node represents a decision point in GPTree.\"\"\"\n    id: int = field(metadata={\"description\": \"The id of the node.\"})\n    label: str = field(metadata={\"description\": \"The label of the node.\"})",
        "detail": "think_reason_learn.gptree._gptree",
        "documentation": {}
    },
    {
        "label": "Answer",
        "kind": 6,
        "importPath": "think_reason_learn.gptree._gptree",
        "description": "think_reason_learn.gptree._gptree",
        "peekOfCode": "class Answer(BaseModel):\n    answer: str\n@dataclass(slots=True)\nclass Node:\n    \"\"\"A Node represents a decision point in GPTree.\"\"\"\n    id: int = field(metadata={\"description\": \"The id of the node.\"})\n    label: str = field(metadata={\"description\": \"The label of the node.\"})\n    question: NodeQuestion | None = field(\n        default=None,\n        metadata={",
        "detail": "think_reason_learn.gptree._gptree",
        "documentation": {}
    },
    {
        "label": "Node",
        "kind": 6,
        "importPath": "think_reason_learn.gptree._gptree",
        "description": "think_reason_learn.gptree._gptree",
        "peekOfCode": "class Node:\n    \"\"\"A Node represents a decision point in GPTree.\"\"\"\n    id: int = field(metadata={\"description\": \"The id of the node.\"})\n    label: str = field(metadata={\"description\": \"The label of the node.\"})\n    question: NodeQuestion | None = field(\n        default=None,\n        metadata={\n            \"description\": \"The chosen question at this node. E.g, \"\n            \"if criterion is gini, then the question with the lowest gini impurity.\"\n        },",
        "detail": "think_reason_learn.gptree._gptree",
        "documentation": {}
    },
    {
        "label": "BuildTask",
        "kind": 6,
        "importPath": "think_reason_learn.gptree._gptree",
        "description": "think_reason_learn.gptree._gptree",
        "peekOfCode": "class BuildTask:\n    node_id: int\n    parent_id: int | None\n    depth: int\n    label: str\n    sample_indices: IndexArray\nclass GPTree:\n    \"\"\"LLM based decision tree classifier.\"\"\"\n    def __init__(\n        self,",
        "detail": "think_reason_learn.gptree._gptree",
        "documentation": {}
    },
    {
        "label": "GPTree",
        "kind": 6,
        "importPath": "think_reason_learn.gptree._gptree",
        "description": "think_reason_learn.gptree._gptree",
        "peekOfCode": "class GPTree:\n    \"\"\"LLM based decision tree classifier.\"\"\"\n    def __init__(\n        self,\n        qgen_llmc: List[LLMChoice],\n        critic_llmc: List[LLMChoice],\n        qgen_instr_llmc: List[LLMChoice],\n        qanswer_llmc: List[LLMChoice] | None = None,\n        qgen_temperature: float = 0.0,\n        critic_temperature: float = 0.0,",
        "detail": "think_reason_learn.gptree._gptree",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "think_reason_learn.gptree._gptree",
        "description": "think_reason_learn.gptree._gptree",
        "peekOfCode": "logger = logging.getLogger(__name__)\nIndexArray = npt.NDArray[np.intp]\n@dataclass(slots=True)\nclass NodeQuestion:\n    \"\"\"A question for generated at a node.\"\"\"\n    value: str = field(metadata={\"description\": \"The question text.\"})\n    choices: List[str] = field(\n        metadata={\"description\": \"The answer choices for the question.\"}\n    )\n    question_type: QuestionType = field(",
        "detail": "think_reason_learn.gptree._gptree",
        "documentation": {}
    },
    {
        "label": "IndexArray",
        "kind": 5,
        "importPath": "think_reason_learn.gptree._gptree",
        "description": "think_reason_learn.gptree._gptree",
        "peekOfCode": "IndexArray = npt.NDArray[np.intp]\n@dataclass(slots=True)\nclass NodeQuestion:\n    \"\"\"A question for generated at a node.\"\"\"\n    value: str = field(metadata={\"description\": \"The question text.\"})\n    choices: List[str] = field(\n        metadata={\"description\": \"The answer choices for the question.\"}\n    )\n    question_type: QuestionType = field(\n        metadata={\"description\": \"The type of the question.\"}",
        "detail": "think_reason_learn.gptree._gptree",
        "documentation": {}
    },
    {
        "label": "num_questions_tag",
        "kind": 5,
        "importPath": "think_reason_learn.gptree._prompts",
        "description": "think_reason_learn.gptree._prompts",
        "peekOfCode": "num_questions_tag = \"<number_of_questions>\"\nINSTRUCTIONS_FOR_GENERATING_QUESTION_GEN_INSTRUCTIONS = f\"\"\"\\\nYou are a helper LLM that writes an instructions template for a question\ngenerator used in a GPTree classification task.\nGoal:\n- Produce a concise, reusable template that instructs a question-generator LLM\n  to generate {num_questions_tag} discriminative questions per node.\n- The template must NOT include prefatory text or labelsreturn only the\n  template content.\n- Allow the generator to decide what to ask based on the task description and",
        "detail": "think_reason_learn.gptree._prompts",
        "documentation": {}
    },
    {
        "label": "INSTRUCTIONS_FOR_GENERATING_QUESTION_GEN_INSTRUCTIONS",
        "kind": 5,
        "importPath": "think_reason_learn.gptree._prompts",
        "description": "think_reason_learn.gptree._prompts",
        "peekOfCode": "INSTRUCTIONS_FOR_GENERATING_QUESTION_GEN_INSTRUCTIONS = f\"\"\"\\\nYou are a helper LLM that writes an instructions template for a question\ngenerator used in a GPTree classification task.\nGoal:\n- Produce a concise, reusable template that instructs a question-generator LLM\n  to generate {num_questions_tag} discriminative questions per node.\n- The template must NOT include prefatory text or labelsreturn only the\n  template content.\n- Allow the generator to decide what to ask based on the task description and\n  the rolling cumulative memory, without over-constraining its creativity.",
        "detail": "think_reason_learn.gptree._prompts",
        "documentation": {}
    },
    {
        "label": "QUESTION_ANSWER_INSTRUCTIONS",
        "kind": 5,
        "importPath": "think_reason_learn.gptree._prompts",
        "description": "think_reason_learn.gptree._prompts",
        "peekOfCode": "QUESTION_ANSWER_INSTRUCTIONS = \"\"\"\\\nYou are an answering agent in a GPTree classification pipeline.\nGiven:\n- A question,\n- A set of allowed answer choices,\n- One sample (text),\nTask:\n- Choose exactly one answer from the provided choices that best fits the sample.\n- Base your decision solely on the sample and the question; do not invent new choices.\n- If multiple choices seem plausible, pick the one most strongly supported",
        "detail": "think_reason_learn.gptree._prompts",
        "documentation": {}
    },
    {
        "label": "CUMULATIVE_MEMORY_INSTRUCTIONS",
        "kind": 5,
        "importPath": "think_reason_learn.gptree._prompts",
        "description": "think_reason_learn.gptree._prompts",
        "peekOfCode": "CUMULATIVE_MEMORY_INSTRUCTIONS = \"\"\"\\\nUsing the prior cumulative memory (if any) and what was just learned at this node,\nwrite a brief note for the next node.\nGuidelines:\n- Summarize key observations and outcomes so far at a high level, and provide gentle\n  hints or priorities for the next node.\n- Treat this as guidance, not a constraint; avoid prescriptive language.\n- Do not repeat raw samples or sensitive details; avoid long quotes.\n- Keep it concise (1-3 sentences).\nReturn:",
        "detail": "think_reason_learn.gptree._prompts",
        "documentation": {}
    },
    {
        "label": "Sample",
        "kind": 5,
        "importPath": "think_reason_learn.gptree._types",
        "description": "think_reason_learn.gptree._types",
        "peekOfCode": "Sample = Dict[str, JSONValue]\nQuestionType = Literal[\"INFERENCE\", \"CODE\"]\nCriterion = Literal[\"gini\"]",
        "detail": "think_reason_learn.gptree._types",
        "documentation": {}
    },
    {
        "label": "QuestionType",
        "kind": 5,
        "importPath": "think_reason_learn.gptree._types",
        "description": "think_reason_learn.gptree._types",
        "peekOfCode": "QuestionType = Literal[\"INFERENCE\", \"CODE\"]\nCriterion = Literal[\"gini\"]",
        "detail": "think_reason_learn.gptree._types",
        "documentation": {}
    },
    {
        "label": "Criterion",
        "kind": 5,
        "importPath": "think_reason_learn.gptree._types",
        "description": "think_reason_learn.gptree._types",
        "peekOfCode": "Criterion = Literal[\"gini\"]",
        "detail": "think_reason_learn.gptree._types",
        "documentation": {}
    }
]